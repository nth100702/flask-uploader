from datetime import datetime
from app import db, app

"""SqlAlchemy database models
"""

class ChunkedFile(db.Model):
    __tablename__ = "chunked_file"
    id = db.Column(db.Integer, primary_key=True)
    # dz fields
    dzuuid = db.Column(db.String(100), nullable=False)  # unique ID per upload file
    dzchunkindex = db.Column(
        db.Integer, nullable=False
    )  # the chunk number of the current upload
    dzchunksize = db.Column(db.Integer, nullable=False)
    dztotalfilesize = db.Column(db.Integer, nullable=False)
    dztotalchunkcount = db.Column(db.Integer, nullable=False)
    dzchunkbyteoffset = db.Column(
        db.Integer, nullable=False
    )  # The place in the file this chunk starts
    # file fields
    chunkpath = db.Column(db.String(100), nullable=False)
    # others
    date_uploaded = db.Column(db.DateTime, nullable=False, default=datetime.now())

    # foreign key
    file_upload_id = db.Column(
        db.Integer, db.ForeignKey("file_upload.id"), nullable=False
    )

    def __repr__(self):
        return f"ChunkedFile('{self.filename}', '{self.date_uploaded}')"


class FileUpload(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    filename = db.Column(db.String(100), nullable=False)
    filepath = db.Column(db.String(100), nullable=False)
    # keep track of chunks
    total_chunks = db.Column(db.Integer, nullable=False)
    chunks_received = db.Column(db.Integer, default=0)
    upload_completed = db.Column(db.Boolean, default=False)
    # timestamp
    date_uploaded = db.Column(db.DateTime, nullable=False, default=datetime.now())

    # a file upload has many chunked files
    chunked_files = db.relationship("ChunkedFile", backref="file_upload")

    # each file upload belongs to a submit record
    submit_record_id = db.Column(
        db.Integer, db.ForeignKey("submit_record.id"), nullable=False
    )

    def __repr__(self):
        return f"FileUpload('{self.filename}', '{self.date_uploaded}')"


class SubmitRecord(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    submit_id_frontend = db.Column(db.String(100), nullable=False)
    all_files_uploaded = db.Column(db.Boolean, default=False)
    date_submitted = db.Column(db.DateTime, nullable=False, default=datetime.now())
    # each submit record has one submitter
    submitter_id = db.Column(db.Integer, db.ForeignKey("user.id"), nullable=False)
    # each submit record has many file uploads
    file_uploads = db.relationship("FileUpload", backref="submit_record")

    def __repr__(self):
        return f"SubmitRecord('{self.date_submitted}', '{self.all_files_uploaded}')"


class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    employee_id = db.Column(db.String(100), nullable=False)
    full_name = db.Column(db.String(100), nullable=False)
    division = db.Column(db.String(100), nullable=False)
    # autogenerated
    date_created = db.Column(db.DateTime, nullable=False, default=datetime.now())

    # each user has one or more submit records
    submit_records = db.relationship("SubmitRecord", backref="user")

    def __repr__(self):
        return f"User('{self.employee_id}', '{self.full_name}', '{self.division}')"

"""
You have to create db tables WITHIN the flask app context
Else you will get an error like this: RuntimeError(unbound_message) from None RuntimeError: Working outside of application context.
Solution: Use app's context manager to create db tables
"""
with app.app_context():
    db.create_all()
